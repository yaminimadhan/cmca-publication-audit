High-level overview
- Minimal vector database using PostgreSQL + pgvector; does NOT generate embeddings.
- Stores items (ids, optional documents, optional metadatas) and precomputed embeddings.
- Provides REST API for: create/list/delete collections, add items, vector search.

Files
- pgvector_db.py: Thin wrapper over PostgreSQL + pgvector (create, add, vector query).
- pgvector_api.py: REST API (vector-only) built on pgvector_db.
- requirements.txt: PostgreSQL/pgvector dependencies only.
- README.md: Usage, API contract, PostgreSQL setup instructions.

End-to-end flow
1) Embeddings team prepares gold-standard texts and generates embeddings.
2) They POST to /items with ids, optional documents/metadatas, and embeddings.
3) Your service stores to a PostgreSQL table with pgvector (persistent in database).
4) For search, they POST query_embeddings to /search/vector and receive nearest neighbors.

API contract (to share with embeddings team)
- POST /collections
  { "collection_name": string, "metadata"?: object }
- GET /collections
- DELETE /collections/{collection_name}
- GET /collections/{collection_name}/count
- POST /items
  {
    "collection_name": string,
    "ids": string[],
    "documents"?: string[],
    "metadatas"?: object[],
    "embeddings"?: number[][]   // required when storing vectors
  }
- POST /search/vector
  {
    "collection_name": string,
    "query_embeddings": number[][],
    "n_results"?: number,
    "where"?: object
  }

Integration requirements (what they must provide)
- collection_name (string)
- ids (List[str])
- embeddings (List[List[float]]) with fixed dimension (model-specific)
- optional: documents (List[str]) and metadatas (List[Dict])
- for search: query_embeddings (List[List[float]]) with same dimension

Decisions to align on
- Collection naming (e.g., "gold_standard_v1").
- Metadata schema (free-form JSON; agree fields like source, category, version).
- Vector dimension (must be consistent across inserts and queries).
- Data lifecycle (replace/delete/versioning strategy if needed).

Optional enhancements (only if required)
- DELETE /items (by ids/where) for cleanup.
- GET /collections/{name}/info returning collection metadata and count.
- Auth (API key) for production.

Runbook
- Setup PostgreSQL + pgvector extension
- Set DATABASE_URL environment variable
- Install: pip install -r requirements.txt
- Start API: python pgvector_api.py
- Create collection: POST /collections { "collection_name": "my_docs" }
- Add items: POST /items with ids + embeddings
- Search: POST /search/vector with query_embeddings
